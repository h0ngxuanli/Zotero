

    博客园Logo
    首页
    新闻
    博问
    会员
    直播
    闪存
    班级

    搜索 搜索
        搜索
        所有博客
        搜索
        当前博客
    注册 登录

返回主页
nancy05

    博客园
    首页
    新随笔
    联系
    订阅
    管理

随笔 - 45  文章 - 0  评论 - 33  阅读 - 93万
Python + logging 输出到屏幕，将log日志写入文件
日志

日志是跟踪软件运行时所发生的事件的一种方法。 软件开发者在代码中调用日志函数，表明发生了特定的事件。 事件由描述性消息描述，该描述性消息可以可选地包含可变数据（即， 对于事件的每次出现都潜在地不同的数据）。 事件还具有开发者归因于事件的重要性；重要性也可以称为级别或严重性。

logging提供了一组便利的函数，用来做简单的日志。它们是 debug()、 info()、 warning()、 error() 和 critical()。

 

logging函数根据它们用来跟踪的事件的级别或严重程度来命名。 标准级别及其适用性描述如下（以严重程度递增排序）：
级别 	何时使用
DEBUG 	详细信息，一般只在调试问题时使用。
INFO 	证明事情按预期工作。
WARNING 	某些没有预料到的事件的提示，或者在将来可能会出现的问题提示。 例如：磁盘空间不足。 但是软件还是会照常运行。
ERROR 	由于更严重的问题，软件已不能执行一些功能了。
CRITICAL 	严重错误，表明软件已不能继续运行了。

 
级别 	数字值
CRITICAL 	50
ERROR 	40
WARNING 	30
INFO 	20
DEBUG 	10
NOTSET 	0

 

默认等级是 WARNING ， 这意味着仅仅这个等级及以上的才会反馈信息，除非logging模块被用来做其它事情。

被跟踪的事件能以不同的方式被处理。 最简单的处理方法就是把它们在控制台上打印出来。 另一种常见的方法就是写入磁盘文件。

 

一、打印到控制台

 import logging logging.debug( ' debug 信息 ' ) logging.warning( ' 只有这个会输出。。。 ' ) logging.info( ' info 信息 ' )

由于默认设置的等级是warning，所有只有warning的信息会输出到控制台。

 WARNING:root:只有这个会输出。。。

 

利用logging.basicConfig()打印信息到控制台
复制代码

 import logging logging.basicConfig(format = ' %(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s ' , level = logging.DEBUG) logging.debug( ' debug 信息 ' ) logging.info( ' info 信息 ' ) logging.warning( ' warning 信息 ' ) logging.error( ' error 信息 ' ) logging.critical( ' critial 信息 ' )

复制代码

由于在logging.basicConfig()中的level 的值设置为logging.DEBUG, 所有debug, info, warning, error, critical 的log都会打印到控制台。

 日志级别： debug < info < warning < error < critical logging.debug( ' debug级别，最低级别，一般开发人员用来打印一些调试信息 ' ) logging.info( ' info级别，正常输出信息，一般用来打印一些正常的操作 ' ) logging.warning( ' waring级别，一般用来打印警信息 ' ) logging.error( ' error级别，一般用来打印一些错误信息 ' ) logging.critical( ' critical 级别，一般用来打印一些致命的错误信息,等级最高 ' )

所以如果设置level = logging.info()的话，debug 的信息则不会输出到控制台。

 

二、利用logging.basicConfig()保存log到文件
复制代码

 logging.basicConfig(level=logging.DEBUG, # 控制台打印的日志级别 
                    filename= ' new.log ' , filemode = ' a ' , # #模式，有w和a，w就是写模式，每次都会重新写日志，覆盖之前的日志 
                    # a是追加模式，默认如果不写的话，就是追加模式 
                    format=
                    ' %(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s ' 
                    # 日志格式 
                    )

复制代码

如果在logging.basicConfig()设置filename 和filemode，则只会保存log到文件，不会输出到控制台。

 

三、既往屏幕输入，也往文件写入log

 

logging库采取了模块化的设计，提供了许多组件：记录器、处理器、过滤器和格式化器。

    Logger 暴露了应用程序代码能直接使用的接口。
    Handler将（记录器产生的）日志记录发送至合适的目的地。
    Filter提供了更好的粒度控制，它可以决定输出哪些日志记录。
    Formatter 指明了最终输出中日志记录的布局。

Loggers:

Logger 对象要做三件事情。首先，它们向应用代码暴露了许多方法，这样应用可以在运行时记录消息。其次，记录器对象通过严重程度（默认的过滤设施）或者过滤器对象来决定哪些日志消息需要记录下来。第三，记录器对象将相关的日志消息传递给所有感兴趣的日志处理器。

常用的记录器对象的方法分为两类：配置和发送消息。

这些是最常用的配置方法：

Logger.setLevel()指定logger将会处理的最低的安全等级日志信息, debug是最低的内置安全等级，critical是最高的内建安全等级。例如，如果严重程度为INFO，记录器将只处理INFO，WARNING，ERROR和CRITICAL消息，DEBUG消息被忽略。
Logger.addHandler()和Logger.removeHandler()从记录器对象中添加和删除处理程序对象。处理器详见Handlers。
Logger.addFilter()和Logger.removeFilter()从记录器对象添加和删除过滤器对象。
Handlers

处理程序 对象负责将适当的日志消息（基于日志消息的严重性）分派到处理程序的指定目标。 Logger  对象可以通过 addHandler() 方法增加零个或多个handler对象。 举个例子，一个应用可以将所有的日志消息发送至日志文件，所有的错误级别（error）及以上的日志消息发送至标准输出，所有的严重级别（critical）日志消息发送至某个电子邮箱。 在这个例子中需要三个独立的处理器，每一个负责将特定级别的消息发送至特定的位置。

常用的有4种： 

1)    logging.StreamHandler -> 控制台输出 


使用这个Handler可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息。

它的构造函数是：
StreamHandler([strm])
其中strm参数是一个文件对象。默认是sys.stderr


2)   logging.FileHandler  -> 文件输出


和StreamHandler类似，用于向一个文件输出日志信息。不过FileHandler会帮你打开这个文件。它的构造函数是：
FileHandler(filename[,mode])
filename是文件名，必须指定一个文件名。
mode是文件的打开方式。默认是’a'，即添加到文件末尾。


3)   logging.handlers.RotatingFileHandler -> 按照大小自动分割日志文件，一旦达到指定的大小重新生成文件 


这个Handler类似于上面的FileHandler，但是它可以管理文件大小。当文件达到一定大小之后，它会自动将当前日志文件改名，然后创建 一个新的同名日志文件继续输出。比如日志文件是chat.log。当chat.log达到指定的大小之后，RotatingFileHandler自动把 文件改名为chat.log.1。不过，如果chat.log.1已经存在，会先把chat.log.1重命名为chat.log.2。。。最后重新创建 chat.log，继续输出日志信息。它的构造函数是：
RotatingFileHandler( filename[, mode[, maxBytes[, backupCount]]])
其中filename和mode两个参数和FileHandler一样。
maxBytes用于指定日志文件的最大文件大小。如果maxBytes为0，意味着日志文件可以无限大，这时上面描述的重命名过程就不会发生。
backupCount用于指定保留的备份文件的个数。比如，如果指定为2，当上面描述的重命名过程发生时，原有的chat.log.2并不会被更名，而是被删除。


4)   logging.handlers.TimedRotatingFileHandler  ->   按照时间自动分割日志文件 


这个Handler和RotatingFileHandler类似，不过，它没有通过判断文件大小来决定何时重新创建日志文件，而是间隔一定时间就 自动创建新的日志文件。重命名的过程与RotatingFileHandler类似，不过新的文件不是附加数字，而是当前时间。它的构造函数是：
TimedRotatingFileHandler( filename [,when [,interval [,backupCount]]])
其中filename参数和backupCount参数和RotatingFileHandler具有相同的意义。
interval是时间间隔。
when参数是一个字符串。表示时间间隔的单位，不区分大小写。它有以下取值：
S 秒
M 分
H 小时
D 天
W 每星期（interval==0时代表星期一）
midnight 每天凌晨

配置方法：

    setLevel() 方法和日志对象的一样，指明了将会分发日志的最低级别。 为什么会有两个 setLevel() 方法？ 记录器的级别决定了消息是否要传递给处理器。 每个处理器的级别决定了消息是否要分发。
    setFormatter() 为该处理器选择一个格式化器。
    addFilter() 和 removeFilter() 分别配置和取消配置处理程序上的过滤器对象。

Formatters

Formatter对象设置日志信息最后的规则、结构和内容，默认的时间格式为%Y-%m-%d %H:%M:%S，下面是Formatter常用的一些信息

%(name)s
	

Logger的名字

%(levelno)s
	

数字形式的日志级别

%(levelname)s
	

文本形式的日志级别

%(pathname)s
	

调用日志输出函数的模块的完整路径名，可能没有

%(filename)s
	

调用日志输出函数的模块的文件名

%(module)s
	

调用日志输出函数的模块名

%(funcName)s
	

调用日志输出函数的函数名

%(lineno)d
	

调用日志输出函数的语句所在的代码行

%(created)f
	

当前时间，用UNIX标准的表示时间的浮 点数表示

%(relativeCreated)d
	

输出日志信息时的，自Logger创建以 来的毫秒数

%(asctime)s
	

字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒

%(thread)d
	

线程ID。可能没有

%(threadName)s
	

线程名。可能没有

%(process)d
	

进程ID。可能没有

%(message)s
	

用户输出的消息

 

 

需求：

输出log到控制台以及将日志写入log文件。
保存2种类型的log， all.log 保存debug, info, warning, critical 信息， error.log则只保存error信息，同时按照时间自动分割日志文件。
复制代码

 import logging  from  logging import handlers  class Logger(object): level_relations  = {  ' debug ' :logging.DEBUG,  ' info ' :logging.INFO,  ' warning ' :logging.WARNING,  ' error ' :logging.ERROR,  ' crit ' :logging.CRITICAL } # 日志级别关系映射 

    def  __init__ (self,filename,level= ' info ' ,when= ' D ' ,backCount=3,fmt= ' %(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s ' ): self.logger  = logging.getLogger(filename) format_str  = logging.Formatter(fmt) # 设置日志格式 
        self.logger.setLevel(self.level_relations.get(level)) # 设置日志级别 
        sh = logging.StreamHandler() # 往屏幕上输出 
        sh.setFormatter(format_str) # 设置屏幕上显示的格式 
        th = handlers.TimedRotatingFileHandler(filename=filename,when=when,backupCount=backCount,encoding= ' utf-8 ' ) # 往文件里写入#指定间隔时间自动生成文件的处理器 
        # 实例化TimedRotatingFileHandler 
        # interval是时间间隔，backupCount是备份文件的个数，如果超过这个个数，就会自动删除，when是间隔的时间单位，单位有以下几种： 
        # S 秒 
        # M 分 
        # H 小时、 
        # D 天、 
        # W 每星期（interval==0时代表星期一） 
        # midnight 每天凌晨 
        th.setFormatter(format_str) # 设置文件里写入的格式 
        self.logger.addHandler(sh) # 把对象加到logger里 
self.logger.addHandler(th)  if  __name__  == ' __main__ ' : log  = Logger( ' all.log ' ,level= ' debug ' ) log.logger.debug( ' debug ' ) log.logger.info( ' info ' ) log.logger.warning( ' 警告 ' ) log.logger.error( ' 报错 ' ) log.logger.critical( ' 严重 ' ) Logger( ' error.log ' , level= ' error ' ).logger.error( ' error ' )

复制代码

屏幕上的结果如下：

 2018-03-13 21:06:46,092 - D:/write_to_log.py[line:25] - DEBUG: debug  2018-03-13 21:06:46,092 - D:/write_to_log.py[line:26] - INFO: info  2018-03-13 21:06:46,092 - D:/write_to_log.py[line:27] - WARNING: 警告  2018-03-13 21:06:46,099 - D:/write_to_log.py[line:28] - ERROR: 报错  2018-03-13 21:06:46,099 - D:/write_to_log.py[line:29] - CRITICAL: 严重  2018-03-13 21:06:46,100 - D:/write_to_log.py[line:30] - ERROR: error

由于when=D，新生成的文件名上会带上时间，如下所示。

 
标签: python3
好文要顶 关注我 收藏该文
nancy05
粉丝 - 193 关注 - 15
+加关注
33
1
« 上一篇： python 多线程小练习
» 下一篇： python ddt 实现数据驱动一
posted @ 2018-03-13 21:26   nancy05   阅读( 299429 )  评论( 14 )  编辑   收藏   举报
刷新评论 刷新页面 返回顶部
登录后才能查看或发表评论，立即 登录 或者 逛逛 博客园首页
【推荐】园子直播第7期：奇计AI创始人左晟《AI时代的商业挑战和机遇》
【推荐】阿里云持续降低用云成本，让算力更普惠：云服务器全面降价
编辑推荐：
· 记一次 .Net 分布式事务死锁现象以及解决方法
· 我坚定的认为，这个源码肯定是有 BUG 的！
· 除了参数，ref 关键字还可以用在什么地方？
· 记一次 etcd 全局锁使用不当导致的事故
· 以管道的方式来完成复杂的流程处理
阅读排行：
· Avalonia 11.0.0 正式版发布
· 记一次.Net分布式事务死锁现象以及解决方法
· 一个C#跨平台的机器视觉和机器学习的开源库
· ASP.NET Core 6框架揭秘实例演示[42]：检查应用的健康状况
· 脱发秘籍：前端Chrome调试技巧汇总
公告
昵称： nancy05
园龄： 11年1个月
粉丝： 193
关注： 15
+加关注
< 	2023年7月 	>
日 	一 	二 	三 	四 	五 	六
25 	26 	27 	28 	29 	30 	1
2 	3 	4 	5 	6 	7 	8
9 	10 	11 	12 	13 	14 	15
16 	17 	18 	19 	20 	21 	22
23 	24 	25 	26 	27 	28 	29
30 	31 	1 	2 	3 	4 	5
搜索
 
 
常用链接

    我的随笔
    我的评论
    我的参与
    最新评论
    我的标签

我的标签

    python3 (37)
    爬虫 (5)
    接口测试 (4)
    Postman (3)
    mysql (3)
    Selenium (3)
    Jmeter (2)
    unittest (2)
    Charles (1)
    抓包 (1)
    更多

随笔档案

    2018年4月(3)
    2018年3月(11)
    2018年2月(12)
    2018年1月(7)
    2017年12月(12)

阅读排行榜

    1. Python + logging 输出到屏幕，将log日志写入文件(299424)
    2. 用Jmeter进行接口测试(131352)
    3. postman 做接口测试之学习笔记(93178)
    4. 备份与还原mysql 数据库的常用命令。(75554)
    5. Selenium + WebDriver 各浏览器驱动下载地址(66575)

评论排行榜

    1. Python + logging 输出到屏幕，将log日志写入文件(14)
    2. postman 做接口测试之学习笔记(6)
    3. 用Jmeter进行接口测试(4)
    4. python3 对excel读、写、修改的操作(3)
    5. python 读写json文件(dump, load)，以及对json格式的数据处理(dumps, loads)(2)

推荐排行榜

    1. Python + logging 输出到屏幕，将log日志写入文件(33)
    2. 用Jmeter进行接口测试(12)
    3. Selenium + WebDriver 各浏览器驱动下载地址(7)
    4. postman 做接口测试之学习笔记(4)
    5. python 读写json文件(dump, load)，以及对json格式的数据处理(dumps, loads)(3)

最新评论

    1. Re:Python + logging 输出到屏幕，将log日志写入文件

    大佬，怎么按时间生成不同的log，而不是追加
    --johnny889
    2. Re:Python + logging 输出到屏幕，将log日志写入文件

    我在： 2021年 10月 17日 19:58:19 看过本篇博客！
    --努力变胖-HWP
    3. Re:Python + logging 输出到屏幕，将log日志写入文件
    @haozhang13 要先新建log空文件夹才不会报错。你需要自动建立，则需新增代码...
    --了了~
    4. Re:Python + logging 输出到屏幕，将log日志写入文件
    你这个日志如果放在函数里面实例化，函数被多次调用，或者在for循环里面实例化，将会发生高斯求和的惨绝人寰的重复记录。 详细看第readme九章的介绍演示有多惨啊...
    --北风之神0509
    5. Re:postman 做接口测试之学习笔记

    楼上这引流做的有够恶心的🤢
    --Helica

Copyright © 2023 nancy05
Powered by .NET 7.0 on Kubernetes
